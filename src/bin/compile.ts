import { readFile, writeFile } from "fs/promises";
import path from "path";
import { Parser } from "@mistts/parser";
import {
    DefineSlotStatement,
    ImportStatement,
    ParamStatement,
} from "@mistts/parser/dist/parser/statement.js";
import { glob } from "glob";
import { Config } from "./config.js";

export async function compileWorkspace(config: Config): Promise<void> {
    const files: string[] = await glob(path.join(config.rootDir, "**/*.mist"));

    console.log(`Found ${files.length} files to compile. `);

    await compile(files, config.rootDir, config.rootDir);

    console.log("Done. ");
}

/** Compile multiple files to TypeScript. */
export async function compile(
    files: string[],
    rootDir: string,
    _outDir: string
): Promise<void> {
    for (const filePath of files) {
        const code = (await readFile(filePath)).toString();

        const parser = new Parser(code, filePath);
        const statements = parser.parse();

        const imports = statements.filter(
            (statement) => statement instanceof ImportStatement
        );
        const slots = statements.filter(
            (statement) => statement instanceof DefineSlotStatement
        );
        const params = statements.filter(
            (statement) => statement instanceof ParamStatement
        );

        let out = `// Autogenerated code by MistTS\n\n`;

        out += "//@ts-ignore\n";
        out += 'import * as $api from "mistts/api"\n\n';

        for (const importStatement of imports) {
            out += `${importStatement.toImportTsStatement()}\n\n`;
        }

        for (const slot of slots) {
            out += `${slot.toTsInterface()}\n\n`;
        }

        out += `export interface $Slots {\n\tmain: {}\n}\n\n`;

        for (const param of params) {
            out += `${param.toTsInterfaceItem()}\n\n`;
        }

        if (params.length === 0) {
            out += "export interface $Params {}\n\n";
        }

        out += "export const $meta = {\n";
        out += `\tsourceFile: "${filePath.slice(rootDir.length + 1)}" as const,\n`;
        out += `\tslots: [${slots.map((slot) => `"${slot.slotNameSafe}"`).join(", ")}] as const,\n`;
        out += "}\n\n";

        const paramArguments = params
            .map(
                (param) =>
                    `${param.variableName}${param.defaultValue ? ` = ${param.defaultValue}` : ""}`
            )
            .join(", ");

        out += "//@ts-ignore\n";
        out += `export async function $render({ ${paramArguments} }: $Params, $slots: Partial<{ [K in keyof $Slots]: {} extends $Slots[K] ? () => Promise<string>: (props: $Slots[K]) => Promise<string> }>): Promise<{ s: true, c: string } | { s: false, l: number, e: any }> {\n`;
        out += "\tlet $line = 0\n";
        out += '\tlet out = ""\n';
        out += "\ttry {\n";

        for (const statement of statements) {
            const compiled = statement.toCompiledString();
            if (!compiled) continue;

            out += `\t${compiled}\n`;
        }

        out += "\treturn { s: true, c: out }\n";
        out += "\t} catch (err) {\n";
        out += "\treturn { s: false, l: $line, e: err }\n";
        out += "\t}\n";

        out += "}";

        const outPath = filePath + ".ts";
        writeFile(outPath, out);

        console.log(`Compiled ${filePath} to ${outPath}. `);
    }
}

